:PROPERTIES:
:header-args:lisp: :package coca.objc :wrap example :exports results
:END:
#+title: Coca/ObjC
#+author: 凉凉
* About
This is =coca/objc= subsystem as Objective-C runtime binding for Common Lisp.

* Stable API
New changes won't break these API.

#+begin_src lisp :exports results
(str:concat
 (asdf:system-description      (asdf:find-system :coca/objc))
 (string #\Newline)
 (string #\Newline)
 (asdf:system-long-description (asdf:find-system :coca/objc)))
#+end_src

#+RESULTS:
#+begin_example
ObjC Runtime bridging in Common Lisp

Coca/ObjC is a Common Lisp bridge to ObjC Runtime.

The API is defined like LispWorks' OBJC API. You could consider Coca/ObjC
as a reimplementation on portable CFFI. But the API may not exactly same as
LispWorks' API.
#+end_example

** Classes
+ =objc-class=

  #+begin_src lisp :exports results
  (documentation (find-class 'objc-class) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Metaclass of ObjC object.

  Use `coerce-to-objc-class' to make an ObjC Class as lisp class.
  All the ObjC class should be cached within `coca.objc::*classes*'.
  #+end_example
+ =standard-objc-object=

  #+begin_src lisp :exports results
  (documentation (find-class 'standard-objc-object) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  The class from which all classes that implement an ObjC class should inherit.

  Dev Note:
  You may not need to directly use `standard-objc-object'.
  It's just a handy CLOS notation of `coca.objc::objc-pointer', making
  ObjC object different if you want to test type of `coca.objc::objc-pointer'.
  #+end_example
+ =sel=

  #+begin_src lisp :exports results
  (documentation (find-class 'sel) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  A foreign type for Objective-C method selectors.

  Use `coerce-to-selector' to make a `sel' object.

  Dev Note:
  Every `sel' instance should be cached within `coca.objc::*sels*'
  So not recommanded to use `make-instance' to alloc `sel' instance.
  #+end_example

** Types
+ =objc-encoding=

  #+begin_src lisp :exports results
  (documentation 'objc-encoding 'type)
  #+end_src

  #+RESULTS:
  #+begin_example
  Type of ObjC encoding representation in lisp.

  See also `objc-basic-encoding'.
  #+end_example

  #+begin_src lisp :exports results
  (documentation 'objc-basic-encoding 'type)
  #+end_src

  #+RESULTS:
  #+begin_example
  Basic ObjC encoding.

      ObjC Type Encoding       objc-basic-encoding
      c                        :char
      C                        :unsigned-char
      i                        :int
      I                        :unsigned-int
      l                        :long
      L                        :unsigned-long
      q                        :long-long
      Q                        :unsigned-long-long
      f                        :float
      d                        :double
      B                        :bool
      v                        :void
      ,*                        :string
      @                        :object
      #                        :class
      :                        :sel
      [len type]               (:array len encoding)
      {NAME=type...}           (:struct NAME)
      (NAME=type...)           (:union  NAME)
      bNUM                     (:bits   NUM)
      ^type                    :pointer
      ?                        :unknown
  #+end_example

+ =define-objc-typedef=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-objc-typedef) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC type alias of NAME for OBJC-ENCODING.

  Example:

      ;; define ObjC type alias
      (define-objc-typedef ns-uinteger :unsigned-long
        "NSUInteger in lisp. ")

      ;; define ObjC type, but overwrite the lisp type
      (define-objc-typedef ns-null :object
        "NSNull"
        'null)

  Syntax:

     (define-objc-typedef NAME OBJC-ENCODING &body [DOC] BODY)

  Parameters:
  + NAME: symbol as lisp type alias
  + OBJC-ENCODING: `objc-encoding'
  + DOC: document string of type
  + TYPE: if given, would generate additional TYPE declaration for NAME
  #+end_example
+ =define-objc-struct=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-objc-struct) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC struct.

  Example:

      ;; the
      (define-objc-struct (ns-point "CGPoint")
        (x :double)
        (y :double))

      ;; overwrite default lisp slot type definition
      (define-objc-struct (ns-rect "CGRect")
        (x :double  :type real)
        (y :double  :type real)
        (w :double  :type real)
        (h :double  :type real))

  Syntax:

      (define-objc-struct (LISP-NAME OBJC-NAME)
        { (SLOT OBJC-ENCODING &key TYPE) }*)

  Parameters:
  + LISP-NAME: symbol of lisp struct
  + OBJC-NAME: string of ObjC struct
  + SLOT: symbol of slot
  + OBJC-ENCODING: ObjC encoding of struct slot
  + TYPE: lisp type of slot,
    if setting, the result should be coerced when copy to foreign

  Dev Note:
  This will define:
  + lisp struct of LISP-NAME
  + cffi struct of LISP-NAME
  + `coca.objc::struct-aref' method implementation
    the struct in Coca.ObjC could be replaced by `simple-vector',
    which means calling with (coca:make-ns-rect ...) is equal to
    calling with (300d0 300d0 400d0 400d0).
  #+end_example
+ =define-objc-enum=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-objc-enum) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC enum of NAME with BINDINGS.

  Example:

  Syntax:

      (define-objc-enum NAME
        [docstring]
        (KEYWORD VAL [docstring]))

  Dev Note:
  this will define:
  + lisp type of NAME
  + a lisp function <NAME>-p to test if is valid flag
  + an encoder function of as-<NAME> to convert enum keywords to unsigned-byte
  + a decoder function of NAME DECODE-<NAME> to convert unsigned-byte to keywords
  #+end_example
+ =define-objc-const=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-objc-const) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define a ObjC constant of OBJC-NAME in lisp as NAME.

  Syntax:

      (define-objc-const name
          (objc-name objc-encoding &optional library)
        [documentation])

  Parameters:
  + NAME: lisp constant name
  + OBJC-NAME: objc global varible name
  + OBJC-ENCODING: should be ObjC-encoding literally
  + LIBRARY: library to search the ObjC global const
  + DOCUMENTATION: optional documentation
  #+end_example

** Methods
+ =coca-init=

  #+begin_src lisp :exports results
  (documentation #'coca-init t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Initialize Coca foreign pointers.

  Dev Note:
  if you save Coca as standalone executable file, you should call
  this method before all the method calling of ObjC methods or objects.

  Use `define-coca-init' to clean up and setup how to reload
  ObjC environment.
  #+end_example

+ =objc-object-pointer=

  #+begin_src lisp :exports results
  (documentation #'objc-object-pointer t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Returns the ObjC foreign pointer associated with a given Lisp object.
  #+end_example
+ =coerce-to-objc-class=

  #+begin_src lisp :exports results
  (documentation #'coerce-to-objc-class t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Coerces its argument to an Objective-C class pointer.
  Return the lisp class of CLASS.

  Parameters:
  + CLASS:
    + `objc-class':
    + symbol: find class and assert it's `objc-class'
    + string: of ObjC class
      this would make an `objc-class' instance class with name CLASS-NAME,
      by default the CLASS-NAME is parsed by `str:param-case' from CLASS,
      or you could set it via optional parameter CLASS-NAME

      this would using `coca.objc::objc_getClass' to get class in the ObjC
      runtime, if not found, raise error.
    + foreign-pointer of ObjC class
      the foreign-pointer would be checked via `coca.objc::object_isClass'
      to test if it's a valid foreign-pointer to ObjC Class

      the name of class would be fetched by `coca.objc::class_getName',
      the CLASS-NAME would be used to set the lisp class name if needed
      (see above as string CLASS input)
  #+end_example

+ =define-objc-class=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-objc-class) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC Class of NAME.

  Example:

      ;; for existing ObjC class,
      ;; `define-objc-class' acts like declaration
      ;; it's direct super class could be ignored
      (define-objc-class "NSWindow" ()
        (("objcProperty" :getter "getObjCProperty"
                           :setter "setObjCProperty:"
                           :before string-to-ns-string))
        (:documentation "Foo... "))

      ;; for non-existing ObjC class,
      ;; `define-objc-class' defines a new ObjC class
      (define-objc-class "MyWindow" (ns-window) ())

      ;; if just want to define all the logic in Lisp,
      ;; omit ObjC class name
      (define-objc-class my-window (ns-window) ())

  Syntax:

      (define-objc-class
          { LISP-NAME | "OBJC-NAME" | ("OBJC-NAME" &optional LISP-NAME) }
          DIRECT-SUPERCLASS
          ({
               (OBJC-PROPERTY &key before after reader accessor documentation)
             | (LISP-SLOT &key LISP-SLOT-DEFINITIONS...)
           }*)
        CLASS-OPTIONS)

  + OBJC-NAME: string of ObjC class name
  + LISP-NAME: lisp name of ObjC class

    if only given LISP-NAME, the class will only be defined as lisp class,
    it would share ObjC class pointer and ObjC class name with it's
    ObjC superclass. This is helpful if you only want to overwrite some
    lisp methods but no intent to overwrite ObjC methods.

  + DIRECT-SUPERCLASS:
    + if not empty:
      + ObjC class is defined before, define a new ObjC class
      + ObjC class is already defined, only modify class slot infomations
    + if empty, only modify the class infomations

    it is adviced to use lisp slots rather than ObjC ivar to store
    infomations, for example:

       (define-objc-class "my-window" (coca:ns-window)
         ("label" :accessor my-window-label))

       (define-objc-class my-window (coca:ns-window)
         (label :accessor my-window-label))

    generally do the same things, but using lisp class and lisp slot
    will be more flexible for your code. You can make use of lisp CLOS
    method combinations.
  + CLASS-OPTIONS:
    + :documentation: set the documentation of the class
  #+end_example

+ =coerce-to-selector=

  #+begin_src lisp :exports results
  (documentation #'coerce-to-selector t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Coerces its argument to an Objective-C method selector.
  Return `sel'.

  Parameters:
  + METHOD: string, `sel' or foreign-pointer.
    + `sel':
      return itself
    + string:
      get the `sel' by name
      see `coca.objc::sel_registerName'
    + foreign-pointer:
      assuming it is a pointer to SEL (not checked)
      see `coca.objc::sel_getName'
  #+end_example
+ =invoke=

  #+begin_src lisp :exports results
  (documentation #'invoke t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Call METHOD on OBJECT by ARGS.
  Return value is wrapped as lisp value.

  Parameters:
  + OBJECT: object, class to call
  + METHOD: sel, string as function

  Return Value:
  + if Class:  wrap as `objc-class'
  + if Object: wrap as `standard-objc-object'
  + if SEL:    wrap as `sel'
  + if struct: as lisp struct (`define-objc-struct')
  + if CFFI compatible value: as CFFI behavior

  Example:

      ;; [NSWindow alloc];
      (invoke "NSWindow" "alloc")

      ;; [NSString initWithUTF8String:"Hello World"];
      (invoke "NSString" "initWithUTF8String:" "Hello World")

      ;; [[NSWindow alloc] initWithContentRect:rect
      ;;                             styleMask:style
      ;;                               backing:backing
      ;;                                 defer:defer]
      (invoke (invoke "NSWindow" "alloc")
              "initWithContentRect:styleMask:backing:defer:"
              rect style backing defer)
  #+end_example
+ =can-invoke-p=

  #+begin_src lisp :exports results
  (documentation #'can-invoke-p t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Test if OBJECT can invoke METHOD or not.

  Parameter:
  + OBJECT:
    + string or symbol of ObjC class name: test both class and instance method
    + `objc-class': test class method
    + `standard-objc-object': test only instance method
    + foreign-pointer: depending on the object's type
  + METHOD: `sel' or things can be `coerce-to-selector'
  #+end_example
+ =define-objc-method=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-objc-method) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC instance METHOD for CLASS.

  Syntax:

      (define-objc-method (CLASS METHOD &optional NAME) RET
          ( { (VAR OBJC-ENCODING) }* )
        (:documentation "docstring")
        (:method ((self class) (arg ...))
          body)
        (:wrapper wrapper-function)
        (:default . BODY))

  + CLASS: symbol or string of ObjC class
    this should be the root of ObjC class where the lisp generic function
    would be used to replace / define ObjC method IMP as callback
  + METHOD: string of method SEL name
  + NAME: lisp generic method name
    if not given, would generated by METHOD (see `coca.objc::objc-intern')
  + RET: ObjC type encoding
    it is recommanded to use `objc-basic-encoding'
  + LAMBDA-LIST:
    VAR: symbol of argument
    OBJC-ENCODING: ObjC type encoding for argument
  + BODY: method body,
    use `self' when referring current ObjC object (adviced, not force)
    use `super' when referring current ObjC object super class

  Example:

      (define-objc-method (ns-window "foo") :bool ()
        (:documentation "...")
        (:default (invoke self balabala))
        (:wrapper as-boolean)
        (:method ((self ns-window))
          (call-next-method) ;; like [super ...] in ObjC
          (foo self)))
  #+end_example
+ =define-coca-init=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-coca-init) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define HOOK to be triggered when init Coca.

  Syntax:

      (define-coca-init { :pre | :post } &body)

  Dev Note:
  + :pre will execute the BODY before `coca-init'
    this is adviced to remove the interned ObjC object
  + :post will execute the BODY after `coca-init'
    this is adviced to rebind the ObjC object

  For example, if you defines an ObjC object as global parameter:

     (defparameter *foo* (get-objc-object-foo))
     (define-coca-init :post (setf *foo* (get-objc-object-foo)))

  This will ensure that the foreign ObjC pointer is correctly
  reinitialized after you close the ObjC environment.
  #+end_example
