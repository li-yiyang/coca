:PROPERTIES:
:header-args:lisp: :package coca.objc :wrap example :exports results
:END:
#+title: Coca/ObjC
#+author: 凉凉
* About
This is =coca/objc= subsystem as Objective-C runtime binding for Common Lisp.

* Stable API
New changes won't break these API.

#+begin_src lisp :exports results
(str:concat
 (asdf:system-description      (asdf:find-system :coca/objc))
 (string #\Newline)
 (string #\Newline)
 (asdf:system-long-description (asdf:find-system :coca/objc)))
#+end_src

#+RESULTS:
#+begin_example
ObjC Runtime bridging in Common Lisp

Coca/ObjC is a Common Lisp bridge to ObjC Runtime.

The API is defined like LispWorks' OBJC API. You could consider Coca/ObjC
as a reimplementation on portable CFFI. But the API may not exactly same as
LispWorks' API.
#+end_example

** Classes
+ =objc-class=

  #+begin_src lisp :exports results
  (documentation (find-class 'objc-class) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Metaclass of ObjC object.

  Use `coerce-to-objc-class' to make an ObjC Class as lisp class.
  All the ObjC class should be cached within `coca.objc::*classes*'.
  #+end_example
+ =standard-objc-object=

  #+begin_src lisp :exports results
  (documentation (find-class 'standard-objc-object) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  The class from which all classes that implement an ObjC class should inherit.

  Dev Note:
  You may not need to directly use `standard-objc-object'.
  It's just a handy CLOS notation of `coca.objc::objc-pointer', making
  ObjC object different if you want to test type of `coca.objc::objc-pointer'.
  #+end_example
+ =sel=

  #+begin_src lisp :exports results
  (documentation (find-class 'sel) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  A foreign type for Objective-C method selectors.

  Use `coerce-to-selector' to make a `sel' object.

  Dev Note:
  Every `sel' instance should be cached within `coca.objc::*sels*'
  So not recommanded to use `make-instance' to alloc `sel' instance.
  #+end_example

** Types
+ =objc-encoding=

  #+begin_src lisp :exports results
  (documentation 'objc-encoding 'type)
  #+end_src

  #+RESULTS:
  #+begin_example
  Type of ObjC encoding representation in lisp.

  See also `objc-basic-encoding'.
  #+end_example

  #+begin_src lisp :exports results
  (documentation 'objc-basic-encoding 'type)
  #+end_src

  #+RESULTS:
  #+begin_example
  Basic ObjC encoding.

      ObjC Type Encoding       objc-basic-encoding
      c                        :char
      C                        :unsigned-char
      i                        :int
      I                        :unsigned-int
      l                        :long
      L                        :unsigned-long
      q                        :long-long
      Q                        :unsigned-long-long
      f                        :float
      d                        :double
      B                        :bool
      v                        :void
      ,*                        :string
      @                        :object
      #                        :class
      :                        :sel
      [len type]               (:array len encoding)
      {NAME=type...}           (:struct NAME)
      (NAME=type...)           (:union  NAME)
      bNUM                     (:bits   NUM)
      ^type                    :pointer
      ?                        :unknown
  #+end_example

+ =define-objc-typedef=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-objc-typedef) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC type alias of NAME for OBJC-ENCODING.

  Example:

      ;; define ObjC type alias
      (define-objc-typedef ns-uinteger :unsigned-long
        "NSUInteger in lisp. ")

      ;; define ObjC type, but overwrite the lisp type
      (define-objc-typedef ns-null :object
        "NSNull"
        'null)

  Syntax:

     (define-objc-typedef NAME OBJC-ENCODING &body [DOC] BODY)

  Parameters:
  + NAME: symbol as lisp type alias
  + OBJC-ENCODING: `objc-encoding'
  + DOC: document string of type
  + TYPE: if given, would generate additional TYPE declaration for NAME
  #+end_example
+ =define-objc-struct=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-objc-struct) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC struct.

  Example:

      ;; the
      (define-objc-struct (ns-point "CGPoint")
        (x :double)
        (y :double))

      ;; overwrite default lisp slot type definition
      (define-objc-struct (ns-rect "CGRect")
        (x :double  :type real)
        (y :double  :type real)
        (w :double  :type real)
        (h :double  :type real))

  Syntax:

      (define-objc-struct (LISP-NAME OBJC-NAME)
        { (SLOT OBJC-ENCODING &key TYPE) }*)

  Parameters:
  + LISP-NAME: symbol of lisp struct
  + OBJC-NAME: string of ObjC struct
  + SLOT: symbol of slot
  + OBJC-ENCODING: ObjC encoding of struct slot
  + TYPE: lisp type of slot,
    if setting, the result should be coerced when copy to foreign

  Dev Note:
  This will define:
  + lisp struct of LISP-NAME
  + cffi struct of LISP-NAME
  + `coca.objc::struct-aref' method implementation
    the struct in Coca.ObjC could be replaced by `simple-vector',
    which means calling with (coca:make-ns-rect ...) is equal to
    calling with (300d0 300d0 400d0 400d0).
  #+end_example
+ =define-objc-enum=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-objc-enum) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC enum of NAME with BINDINGS.

  Example:

  Syntax:

      (define-objc-enum NAME
        [docstring]
        (KEYWORD* VAL [docstring]))

      KEYWORD* := KEYWORD
                | (KEYWORD ...MORE-KEYWORDS)

  Parameters:
  + NAME: the name of enum values as lisp type
  + KEYWORD*: when decoding the enum value,
    the first KEYWORD would be returned as decoded value
    the rest could be used when generating the enum value

  Dev Note:
  this will define:
  + lisp type of NAME
  + a lisp function <NAME>-p to test if is valid flag
  + an encoder function of as-<NAME> to convert enum keywords to unsigned-byte
  + a decoder function of NAME DECODE-<NAME> to convert unsigned-byte to keywords
  + different to `define-objc-mask' the enum should only be single keyword
  #+end_example
+ =define-objc-mask=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-objc-mask) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC enum as mask of NAME with BINDINGS.

  Example:

  Syntax:

      (define-objc-mask NAME
        [docstring]
        (KEYWORD VAL [docstring]))

      KEYWORD* := KEYWORD
                | (KEYWORD ...MORE-KEYWORDS)

  Parameters:
  + NAME: the name of enum values as lisp type
  + KEYWORD*: when decoding the enum value,
    the first KEYWORD would be returned as decoded value
    the rest could be used when generating the enum value

  Dev Note:
  this will define:
  + lisp type of NAME
  + a lisp function <NAME>-p to test if is valid flag
  + an encoder function of as-<NAME> to convert enum keywords to unsigned-byte
  + a decoder function of NAME DECODE-<NAME> to convert unsigned-byte to keywords
  + different to `define-objc-enum' the mask could also be a list of keyword
  #+end_example

+ =define-objc-const=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-objc-const) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define a ObjC constant of OBJC-NAME in lisp as NAME.

  Syntax:

      (define-objc-const name
          (objc-name objc-encoding &optional library)
        [documentation])

  Parameters:
  + NAME: lisp constant name
  + OBJC-NAME: objc global varible name
  + OBJC-ENCODING: should be ObjC-encoding literally
  + LIBRARY: library to search the ObjC global const
  + DOCUMENTATION: optional documentation
  #+end_example

** Methods
+ =coca-init=

  #+begin_src lisp :exports results
  (documentation #'coca-init t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Initialize Coca foreign pointers.

  Dev Note:
  if you save Coca as standalone executable file, you should call
  this method before all the method calling of ObjC methods or objects.

  Use `define-coca-init' to clean up and setup how to reload
  ObjC environment.
  #+end_example

+ =objc-object-pointer=

  #+begin_src lisp :exports results
  (documentation #'objc-object-pointer t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Returns the ObjC foreign pointer associated with a given Lisp object.
  #+end_example
+ =coerce-to-objc-class=

  #+begin_src lisp :exports results
  (documentation #'coerce-to-objc-class t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Coerces its argument to an Objective-C class pointer.
  Return the lisp class of CLASS.

  Parameters:
  + CLASS:
    + `objc-class':
    + symbol: find class and assert it's `objc-class'
    + string: of ObjC class
      this would make an `objc-class' instance class with name CLASS-NAME,
      by default the CLASS-NAME is parsed by `str:param-case' from CLASS,
      or you could set it via optional parameter CLASS-NAME

      this would using `coca.objc::objc_getClass' to get class in the ObjC
      runtime, if not found, raise error.
    + foreign-pointer of ObjC class
      the foreign-pointer would be checked via `coca.objc::object_isClass'
      to test if it's a valid foreign-pointer to ObjC Class

      the name of class would be fetched by `coca.objc::class_getName',
      the CLASS-NAME would be used to set the lisp class name if needed
      (see above as string CLASS input)
  #+end_example

+ =define-objc-class=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-objc-class) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC Class of NAME.

  Example:

      ;; for existing ObjC class,
      ;; `define-objc-class' acts like declaration
      ;; it's direct super class could be ignored
      (define-objc-class "NSWindow" ()
        (("objcProperty" :getter "getObjCProperty"
                           :setter "setObjCProperty:"
                           :before string-to-ns-string))
        (:documentation "Foo... "))

      ;; for non-existing ObjC class,
      ;; `define-objc-class' defines a new ObjC class
      (define-objc-class "MyWindow" (ns-window) ())

  Syntax:

      (define-objc-class
          { "OBJC-NAME" | ("OBJC-NAME" &optional LISP-NAME) }
          DIRECT-SUPERCLASS
          ({
               (OBJC-PROPERTY &key before after reader accessor documentation)
             | (LISP-SLOT &key LISP-SLOT-DEFINITIONS...)
           }*)
        CLASS-OPTIONS)

  + OBJC-NAME: string of ObjC class name
  + LISP-NAME: lisp name of ObjC class (optional)
  + DIRECT-SUPERCLASS:
    if not empty, will be used to declare new ObjC class
    if the ObjC class is not defined before;
    if empty, it's equal to modify the class infomations
  + CLASS-OPTIONS:
    + :documentation: set the documentation of the class
  #+end_example

+ =coerce-to-selector=

  #+begin_src lisp :exports results
  (documentation #'coerce-to-selector t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Coerces its argument to an Objective-C method selector.
  Return `sel'.

  Parameters:
  + METHOD: string, `sel' or foreign-pointer.
    + `sel':
      return itself
    + string:
      get the `sel' by name
      see `coca.objc::sel_registerName'
    + foreign-pointer:
      assuming it is a pointer to SEL (not checked)
      see `coca.objc::sel_getName'
  #+end_example
+ =invoke=

  #+begin_src lisp :exports results
  (documentation #'invoke t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Call METHOD on OBJECT by ARGS.
  Return value is wrapped as lisp value.

  Parameters:
  + OBJECT: object, class to call
  + METHOD: sel, string as function

  Return Value:
  + if Class:  wrap as `objc-class'
  + if Object: wrap as `standard-objc-object'
  + if SEL:    wrap as `sel'
  + if struct: as lisp struct (`define-objc-struct')
  + if CFFI compatible value: as CFFI behavior

  Example:

      ;; [NSWindow alloc];
      (invoke "NSWindow" "alloc")

      ;; [NSString initWithUTF8String:"Hello World"];
      (invoke "NSString" "initWithUTF8String:" "Hello World")

      ;; [[NSWindow alloc] initWithContentRect:rect
      ;;                             styleMask:style
      ;;                               backing:backing
      ;;                                 defer:defer]
      (invoke (invoke "NSWindow" "alloc")
              "initWithContentRect:styleMask:backing:defer:"
              rect style backing defer)
  #+end_example
+ =can-invoke-p=

  #+begin_src lisp :exports results
  (documentation #'can-invoke-p t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Test if OBJECT can invoke METHOD or not.

  Parameter:
  + OBJECT:
    + string or symbol of ObjC class name: test both class and instance method
    + `objc-class': test class method
    + `standard-objc-object': test only instance method
    + foreign-pointer: depending on the object's type
  + METHOD: `sel' or things can be `coerce-to-selector'
  #+end_example
+ =define-objc-method=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-objc-method) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC instance METHOD for CLASS.

  Syntax:

      (define-objc-method (CLASS METHOD &optional NAME) RET
          ( { (VAR OBJC-ENCODING) }* )
        (:documentation "docstring")
        (:method ((self class) (arg ...))
          body)
        (:wrapper wrapper-function)
        (:default default-return-value))

  + CLASS: symbol or string of ObjC class
    this should be the root of ObjC class where the lisp generic function
    would be used to replace / define ObjC method IMP as callback
  + METHOD: string of method SEL name
  + NAME: lisp generic method name
    if not given, would generated by METHOD (see `coca.objc::objc-intern')
  + RET: ObjC type encoding
    it is recommanded to use `objc-basic-encoding'
  + LAMBDA-LIST:
    VAR: symbol of argument
    OBJC-ENCODING: ObjC type encoding for argument

  Example:

      (define-objc-method (ns-window "foo") :bool ()
        (:documentation "...")
        (:wrapper as-boolean)
        (:method ((self ns-window))
          (call-next-method) ;; like [super ...] in ObjC
          (foo self)))
  #+end_example
+ =define-coca-init=

  #+begin_src lisp :exports results
  (documentation (macro-function 'define-coca-init) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define HOOK to be triggered when init Coca.

  Syntax:

      (define-coca-init { :pre | :post } &body)

  Dev Note:
  + :pre will execute the BODY before `coca-init'
    this is adviced to remove the interned ObjC object
  + :post will execute the BODY after `coca-init'
    this is adviced to rebind the ObjC object

  For example, if you defines an ObjC object as global parameter:

     (defparameter *foo* (get-objc-object-foo))
     (define-coca-init :post (setf *foo* (get-objc-object-foo)))

  This will ensure that the foreign ObjC pointer is correctly
  reinitialized after you close the ObjC environment.
  #+end_example

* Literal Programming                                              :noexport:
** GenDoc
*NOTE*: this is only needed if publishing =readme.org= for Github
org-mode rendering.

#+begin_src elisp :results silent
(save-excursion
  (beginning-of-buffer)
  (while (search-forward-regexp
          "^\s*#\\+begin_src lisp :exports results"
          nil t)
    (org-ctrl-c-ctrl-c)
    (next-line)))
#+end_src

Use =:exports results= for Github org-mode to recongize.
Evaluating this would update all the =:exports results= code block
within current file.
