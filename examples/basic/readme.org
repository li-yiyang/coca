:PROPERTIES:
:header-args:lisp: :package coca :results silent :eval no-export
:END:
#+title: Basic
#+subtitle: Examples about how to use Coca
#+author: 凉凉
#+OPTIONS: ^:{}
* A Very basic window
** Plain =ns-window=
First, load =coca= package:

#+begin_src lisp
(ql:quickload :coca)
#+end_src

the following codes are assuming you're running codes
under =coca= package.

#+begin_src lisp
(in-package :coca)
#+end_src

#+begin_src lisp :noweb yes no-export
<<terminate-app-loop-when-close-window>>

(tmt:with-body-in-main-thread (:blocking t)
  (sb-int:set-floating-point-modes :traps nil)
  (let ((app (ns-app))
        (win (alloc-init 'ns-window
                         :frame   (make-ns-rect :x 100 :y 100
                                                :w 300 :h 300)
                         :title   "A Very basic window"
                         :visiblep t)))
    (run app)))
#+end_src

#+html: <details><summary>notes...</summary>
Here we use =terminate= to terminate =ns-app=,
which is the =NSApplication= of the application.

#+name: terminate-app-loop-when-close-window
#+begin_src lisp
(defmethod window-should-close ((self ns-window) sender)
  (terminate (ns-app) sender)
  t)
#+end_src

if you found your lisp also dies, it's normal.
#+html: </details>

*Reference*:
+ [[https://github.com/gammasoft71/Examples_Cocoa/blob/master/src/Applications/Application/Application.m][Application.m]] ([[https://github.com/gammasoft71/Examples_Cocoa/][Cocoa examples (github:gammasoft71/Examples_Cocoa)]])

*Explain*:
+ =ns-app= invokes =[NSApplication sharedApplication]= and return the =NSApp=,
  which handles the application event-loop of a Cocoa application (ref: [[https://developer.apple.com/documentation/appkit/nsapp?language=objc][NSApp]])
+ =alloc-init= is equal to calling =(init (alloc 'ns-window) ...)=,
  you could implement your own =init= (lisp generic function) to customize
  how to initialize the ObjC object.

  Note: =init= doesn't overwrites ObjC method =init=, so you can invoke
  ObjC =init= like =(invoke object "init")= within your lisp =init= [fn:lispworks-init].

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (find-method #'init () (list (find-class 'ns-window))) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Initializes the window with the specified values.
  Return the initialized `ns-window'.

  Parameters:
  + FRAME: `ns-rect'
    Origin and size of the window’s content area in screen
    coordinates. Note that the window server limits window position
    coordinates to ±16,000 and sizes to 10,000.
  + STYLE: see `ns-window-style-mask' (default `*ns-window-style*')
    The window’s style. It can be NSBorderlessWindowMask, or it can
    contain any of the options described in NSWindowStyleMask, combined
    using the C bitwise OR operator. Borderless windows display none of
    the usual peripheral elements and are generally useful only for
    display or caching purposes; you should normally not need to create
    them. Also, note that a window’s style mask should include
    NSTitledWindowMask if it includes any of the others.
  + BACKING: see `ns-backing-store-type' (default `*ns-backing-store*')
    Specifies how the drawing done in the window is buffered by the
    window device, and possible values are described in
    NSBackingStoreType.
  + DEFER:
    Specifies whether the window server creates a window device for the
    window immediately. When true, the window server defers creating the
    window device until the window is moved onscreen. All display
    messages sent to the window or its views are postponed until the
    window is created, just before it’s moved onscreen.
  + SCREEN: `ns-screen'
    Specifies the screen on which the window is positioned. The content
    rectangle is positioned relative to the bottom-left corner of
    screen. When nil, the content rectangle is positioned relative to
    (0, 0), which is the origin of the primary screen.

  Styls Modification:
  + VISIBLE:
    if window is visible on screen (default `t')
  + HAS-SHADOW:
    if window has shadow (default `t')
  + OPAQUE:
    if window is opaque (default `nil')
  + TITLE:
    the title of window (default not set)

  Dev Note:
  this invokes
  + initWithContentRect:styleMask:backing:defer:screen:
  + initWithContentRect:styleMask:backing:defer:

  see https://developer.apple.com/documentation/appkit/nswindow/init(contentrect:stylemask:backing:defer:)?language=objc
  see https://developer.apple.com/documentation/appkit/nswindow/init(contentrect:stylemask:backing:defer:screen:)?language=objc
  #+end_example
  #+html: </details>
+ =(sb-int:set-floating-point-modes :traps nil)= is needed on SBCL to avoid
  float traps stucking the main loop

** =ns-window= with =ns-text-field=
#+begin_src lisp :noweb yes no-export
<<terminate-app-loop-when-close-window>>

(tmt:with-body-in-main-thread ()
  (sb-int:set-floating-point-modes :traps nil)
  (let ((app   (ns-app))
        (win   (alloc-init 'ns-window
                           :frame   (make-ns-rect :x 100 :y 100
                                                  :w 300 :h 300)
                           :title   "A Very basic window"
                           :visiblep t))
        (label (alloc-init 'ns-text-field
                           :frame       (make-ns-rect :x 5 :y 100 :w 290 :h 100)
                           :font        (as-ns-font :label
                                                    :traits '(:italic :bold)
                                                    :size   45)
                           :text        "Hello World! "
                           :bezeledp    nil
                           :backgroundp nil
                           :editablep   nil
                           :selectablep nil
                           :text-color  #(0.0 0.5 0.0))))
    (add-subview win label)
    (run app)))
#+end_src

#+attr_html: :width 80%
#+attr_org: :width 300px
#+caption: Hello World (with label)
[[file:./hello-world.png]]

*Reference*:
+ [[https://github.com/gammasoft71/Examples_Cocoa/blob/master/src/HelloWorlds/HelloWorld/HelloWorld.m][HelloWorld.m]] ([[https://github.com/gammasoft71/Examples_Cocoa/][Cocoa examples (github:gammasoft71/Examples_Cocoa)]])

*Explain*:
+ =(alloc-init 'ns-text-field)=

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (find-method #'init () (list (find-class 'ns-text-field))) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Initialize NSTextField.

  Parameters:
  + FRAME: `ns-rect'
    The frame rectangle for the created view object.
    If setting, will use initWithFrame: method to initialize the
    `ns-text-field'.
  + TEXT:
    The string value of `ns-text-field' (see `string-value')

  Styles Parameters:
  + DRAWS-BACKGROUND-P:
    if or not draws background (see `draws-background-p')
  + BACKGROUND-COLOR:
    set the text field background color (see `background-color')
    if setting, will force DRAWS-BACKGROUND-P as `t'
  + TEXT-COLOR:  set the text color (see `text-color')
  + EDITABLEP:   set the text field is editable or not (see `editablep')
  + SELECTABLEP: set the text field is selectable or not (see `selectablep')
  + FONT:        set the text field (see `as-ns-font')
  + BEZELEDP:    set if draws bezeled background (boarder) (see `bezeledp')
  #+end_example
  #+html: </details>
+ =:label= font in Coca is wrapped by =as-ns-font= method

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (find-method #'as-ns-font () (list (c2mop:intern-eql-specializer :label))) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Returns the font used for standard interface labels in the
  specified size.

  This invokes ObjC method labelFontOfSize:

  The label font (Lucida Grande Regular 10 point) is used for the labels
  on toolbar buttons and to label tick marks on full-size sliders. See
  The macOS Environment in macOS Human Interface Guidelines for more
  information about system fonts.

  see https://developer.apple.com/documentation/appkit/nsfont/labelfont(ofsize:)?language=objc
  #+end_example

+ =:green= color in Coca is wrapped by =as-ns-color= method

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (find-method #'as-ns-color () (list (c2mop:intern-eql-specializer :green))) t)
  #+end_src

  #+RESULTS:
  : Returns a color object whose RGB value is 0.0, 1.0, 0.0 and whose
  : alpha value is 1.0.
+ =add-subview= add =label= to subview (like HTML children) of =win=

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (find-method #'add-subview () (list (find-class 'ns-window) (find-class 'ns-view))) t)
  #+end_src

  #+RESULTS:
  : This is equal to calling (add-subview (content-view WINDOW) SUBVIEW).

** Custom ObjC class and custom ObjC methods
If don't want =(ns-app)= being terminated for all the =ns-window=,
we could define a new ObjC class and use CLOS generic method to implement
different logic for the ObjC class.

#+begin_src lisp
(define-objc-class ("MyWindow" my-window) (ns-window)
  ((label :accessor my-label))
  (:documentation "The window will stop `ns-app' when closed. "))

(defmethod window-should-close ((self my-window) sender)
  (terminate (ns-app) sender)
  t)

(defmethod init ((self my-window)
                 &rest plist
                 &key
                   (label "Hello ObjC Class")
                   (title "Hello World"))
  (setf (getf plist :title) title)
  (apply #'call-next-method self plist)
  (setf (my-label self)
        (alloc-init 'ns-text-field
                    :frame       (make-ns-rect :x 5 :y 100 :w 290 :h 100)
                    :font        (as-ns-font :label
                                             :traits '(:italic :bold)
                                             :size   45)
                    :text        label
                    :bezeledp    nil
                    :backgroundp nil
                    :editablep   nil
                    :selectablep nil
                    :text-color  #(0.0 0.5 0.0)))
  (add-subview self (my-label self)))

(tmt:with-body-in-main-thread (:blocking t)
  (sb-int:set-floating-point-modes :traps nil)
  (let ((app (ns-app)))
    (alloc-init 'my-window
                :frame   (make-ns-rect :x 100 :y 100
                                       :w 300 :h 300)
                :visiblep t)
    (run app)))
#+end_src

*Explain*
+ =define-objc-class=: this defines a new ObjC class =MyClass=
  and wrap as lisp class of name =my-window=.

  Note that although it's possible to define a ObjC Ivar using
  syntax like =("IvarName" :reader balabala)=. But it's not
  recommanded since this does not support dynamically redefine
  like CLOS =defclass=.

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (macro-function 'define-objc-class) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC Class of NAME.

  Example:

      ;; for existing ObjC class,
      ;; `define-objc-class' acts like declaration
      ;; it's direct super class could be ignored
      (define-objc-class \"NSWindow\" ()
        ((\"objcProperty\" :getter \"getObjCProperty\"
                           :setter \"setObjCProperty:\"
                           :before string-to-ns-string))
        (:documentation \"Foo... \"))

      ;; for non-existing ObjC class,
      ;; `define-objc-class' defines a new ObjC class
      (define-objc-class \"MyWindow\" (ns-window) ())

  Syntax:

      (define-objc-class
          { \"OBJC-NAME\" | (\"OBJC-NAME\" &optional LISP-NAME) }
          DIRECT-SUPERCLASS
          ({
               (OBJC-PROPERTY &key before after reader accessor documentation)
             | (LISP-SLOT &key LISP-SLOT-DEFINITIONS...)
           }*)
        CLASS-OPTIONS)

  + OBJC-NAME: string of ObjC class name
  + LISP-NAME: lisp name of ObjC class (optional)
  + DIRECT-SUPERCLASS:
    if not empty, will be used to declare new ObjC class
    if the ObjC class is not defined before;
    if empty, it's equal to modify the class infomations
  + CLASS-OPTIONS:
    + :documentation: set the documentation of the class
  #+end_example
  #+html: </details>
+ =call-next-method=: this works like =super= in ObjC, but you
  could make full use of ObjC method combination. ([[https://www.lispworks.com/documentation/HyperSpec/Body/f_call_n.htm][ref (CLHS)]])

  Note: if you want to wrap ObjC method as lisp generic methods,
  you could use =define-objc-method=. The =window-should-close=
  is defined like:

  #+begin_src lisp
  (define-objc-method ("NSWindow" "windowShouldClose:" window-should-close) :bool
    ((sender :object)))
  #+end_src

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (macro-function 'define-objc-method) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC instance METHOD for CLASS.

  Syntax:

      (define-objc-method (CLASS METHOD &optional NAME) RET
          ( { (VAR OBJC-ENCODING) }* )
        (:documentation \"docstring\")
        (:method ((self class) (arg ...))
          body)
        (:wrapper wrapper-function)
        (:default . BODY))

  + CLASS: symbol or string of ObjC class
    this should be the root of ObjC class where the lisp generic function
    would be used to replace / define ObjC method IMP as callback
  + METHOD: string of method SEL name
  + NAME: lisp generic method name
    if not given, would generated by METHOD (see `coca.objc::objc-intern')
  + RET: ObjC type encoding
    it is recommanded to use `objc-basic-encoding'
  + LAMBDA-LIST:
    VAR: symbol of argument
    OBJC-ENCODING: ObjC type encoding for argument
  + BODY: method body,
    use `self' when referring current ObjC object (adviced, not force)
    use `super' when referring current ObjC object super class

  Example:

      (define-objc-method (ns-window \"foo\") :bool ()
        (:documentation \"...\")
        (:default (invoke self balabala))
        (:wrapper as-boolean)
        (:method ((self ns-window))
          (call-next-method) ;; like [super ...] in ObjC
          (foo self)))
  #+end_example
  #+html: </details>

* Dialog
** ColorDialog
#+begin_src lisp
(define-objc-class ("ColorWindow" color-window) (ns-window) ())

(define-objc-method ("ColorWindow" "onButtonClick:" on-button-click) :void
    ((sender :object))
  (:method ((self ns-window) (sender t))
    (let ((panel (ns-color-panel :target self
                                 :action #'change-color
                                 :color  (background-color self))))
      (setf (visiblep panel) t))))

(defmethod change-color ((self ns-window) (sender t))
  (setf (background-color self) (color sender)))

(defmethod init ((self color-window) &key)
  (let ((button (alloc-init 'ns-button
                            :frame (make-ns-rect :x 10 :y 265 :w 100 :h 32)
                            :title "Color..."
                            :bezel-style :rounded
                            :target self
                            :action #'on-button-click
                            :autoresizing '(:max-x-margin :min-y-margin))))
    (call-next-method self
                      :frame (make-ns-rect :x 100 :y 100 :w 300 :h 300)
                      :title "ColorDialog example"
                      :visiblep t)
    (add-subview self button)
    self))

<<window-should-close>>

(tmt:with-body-in-main-thread ()
  (sb-int:set-floating-point-modes :traps ())
  (let ((app (ns-app)))
    (setf (activation-policy app) :regular)
    (make-main-window (autorelease (alloc-init 'color-window)))
    (run app)))
#+end_src

#+attr_html: :width 80%
#+attr_org: :width 300px
#+caption: ColorDialog example
[[file:./color-dialog.gif]]

#+html: <details><summary>window-should-close</summary>
#+begin_src lisp
(defmethod window-should-close :after (self sender)
  (when (endp (remove-if (lambda (w)
                           (or (typep w 'ns-panel)
                               (eq w self)))
                         (windows (ns-app))))
    (terminate (ns-app) sender)))
#+end_src

*Reference*:
+ [[https://github.com/gammasoft71/Examples_Cocoa/blob/master/src/Dialogs/ColorDialog/ColorDialog.m][ColorDialog.m]] ([[https://github.com/gammasoft71/Examples_Cocoa/][Cocoa examples (github:gammasoft71/Examples_Cocoa)]])

*Note*: this might be rewritten in the future for clean code.
#+html: </details>

*Explain*:
+ =ColorWindow=: we define a new =ns-window= class which:
  + Holds a button with title =Color...=
  + if button clicked, send =on-button-click= (ObjC method =onButtonClick:=)
    action to target aka =ColorWindow= itself

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (find-method #'init () (list (find-class 'ns-button))) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Creates a standard push button with the title you specify.

  Parameters:
  + TARGET: The target object that receives action messages from the control.
  + ACTION: The action the button sends to the target.
    see `coerce-to-selector'
  + TITLE:  The localized title string to display on the button.
  + IMAGE:  The image to display in the body of the button.
  + BORDEREDP: if BUTTON has border
    see `borderedp'
  + BEZEL-STYLE: appearance of button border (`ns-bezel-style')
    see `bezel-style'
  + BEZEL-COLOR: color of the button’s bezel (`as-ns-color')
    see `bezel-color'
  + BUTTON-TYPE: button type (`*ns-button-type*')
    see `ns-button-type'

  Dev Note:
  at least one of TITLE and IMAGE should be given.
  #+end_example

  #+html: </details>
+ =ns-color-panel=: when ObjC environment invokes =on-button-click=
  method, a [[https://developer.apple.com/documentation/appkit/nscolorpanel?language=objc][NSColorPanel]] ([[https://developer.apple.com/documentation/appkit/nscolorpanel/shared?language=objc][sharedColorPanel]]) panel window will:
  + popup =(setf (visiblep panel) t)=
  + start with initial color (background color of current window)
  + when changing the color of color panel,
    will send a =action= (ObjC SEL as message) to =target=
    (current window) with (the color panel) itself.

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'ns-color-panel t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Returns the shared NSColorPanel instance, creating it if necessary.

  Parameters:
  + TARGET: sets the target of the receiver
  + ACTION: sets the color panel's action message (default `change-color')
  + COLOR:  sets the color panel initial color
  + CONTINUOUSP: whether the receiver continuously sends
    the action message to the target
  + MODE: sets the mode of the receiver (`ns-color-panel-mode')

  see https://developer.apple.com/documentation/appkit/nscolorpanel/shared?language=objc
  #+end_example

  #+html: </details>

** FontDialog
#+begin_src lisp
(define-objc-class ("FontWindow" font-window) (ns-window)
  ((label :accessor my-label)))

(define-objc-method ("FontWindow" "onButtonClick:" on-button-click) :void
    ((sender :object))
  (:method ((self font-window) sender)
    (ns-font-panel :font   (font (my-label self))
                   :target self
                   :action #'change-font
                   :sender self)))

(defmethod change-font ((self font-window) sender)
  (setf (font (my-label self)) (selected-font (ns-font-manager))))

(defmethod init ((self font-window) &key)
  (let ((button (alloc-init 'ns-button
                            :frame (make-ns-rect :x 10 :y 365 :w 100 :h 32)
                            :title "Font..."
                            :bezel-style :rounded
                            :target self
                            :action #'on-button-click
                            :autoresizing '(:max-x-margin :min-y-margin)))
        (label  (alloc-init 'coca:ns-text-field
                            :frame (make-ns-rect :x 10 :y 10 :w 380 :h 345)
                            :text  "Coca is Cocoa in Common Lisp.
ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
1234567890!@#$%^&*()-+_=
滚滚长江东逝水
凉凉")))
    (call-next-method self
                      :frame (make-ns-rect :x 100 :y 100 :w 400 :h 400)
                      :title "FontDialog example"
                      :visiblep t)
    (add-subview self button)
    (add-subview self (setf (my-label self) label))
    self))

<<window-should-close>>

(tmt:with-body-in-main-thread ()
  (sb-int:set-floating-point-modes :traps ())
  (let ((app (ns-app)))
    (setf (activation-policy app) :regular)
    (make-main-window (autorelease (alloc-init 'font-window)))
    (run app)))
#+end_src

#+caption: FontDialog example
[[file:./font-dialog.gif]]

*Reference*:
+ [[https://github.com/gammasoft71/Examples_Cocoa/blob/master/src/Dialogs/FontDialog/FontDialog.m][FontDialog.m]] ([[https://github.com/gammasoft71/Examples_Cocoa/][Cocoa examples (github:gammasoft71/Examples_Cocoa)]])

*Explain*:
+ =ns-font-panel= creates a [[https://developer.apple.com/documentation/appkit/nsfontpanel?language=objc][NSFontPanel]] to select fonts

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'ns-font-panel t)
  #+end_src

  #+RESULTS:
  : Returns the single NSFontPanel instance for the application,
  : creating it if necessary.
  :
  : Parameters:
  : + FONT:     `ns-font' object to be show in font panel
  : + MULTIPLE: If true, the Font panel indicates that more than one font
  :   is contained in the selection; if false, it does not.
  : + TARGET:   target to send ACTION when changing font
  : + ACTION:   action to be sent (default `change-font')

  #+html: </details>
+ =change-font= is the default ObjC callback function
  responding to the =NSFontPanel= font changing events

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'change-font t)
  #+end_src

  #+RESULTS:
  : Called to respond to font changing events.
  :
  : Parameters:
  : + SELF:   responder to the message
  : + SENDER: the control that send the message

  #+html: </details>

* Literal Programming                                              :noexport:
** GenDoc
*NOTE*: this is only needed if publishing =readme.org= for Github
org-mode rendering.

#+begin_src elisp :results silent
(save-excursion
  (beginning-of-buffer)
  (while (search-forward-regexp
          "^\s*#\\+begin_src lisp :exports results"
          nil t)
    (org-ctrl-c-ctrl-c)
    (next-line)))
#+end_src

Use =:exports results= for Github org-mode to recongize.
Evaluating this would update all the =:exports results= code block
within current file.

* Footnotes

[fn:lispworks-init] This may more likely to be LispWorks' =:init-function=
when defining a new ObjC class, which is called to initialize ObjC object
from the lisp side.
