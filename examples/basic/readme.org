:PROPERTIES:
:header-args:lisp: :package coca :results silent :eval no-export
:END:
#+title: Basic
#+subtitle: Examples about how to use Coca
#+author: 凉凉
#+OPTIONS: ^:{}
* Status
- [X] Hello Worlds
- [X] Applications
- [-] Dialogs
  - [X] ColorDialog
  - [X] FontDialog
  - [X] FileOpen/SaveDialog
  - [ ] MessageBox
- [ ] Menus and toolbars
- [ ] Containers
  - [ ] NSBox
  - [ ] NSScrollView
  - [ ] NSTabView
  - [ ] NSWindow
- [-] Controls
  - [X] Button
  - [ ] CheckBox
  - [ ] ComboBox
  - [ ] Label
  - [ ] LevelIndicator
  - [ ] ListBox
- [ ] Components
  - [ ] Timer
- [ ] Events
  - [ ] ApplicationIdle
  - [ ] WindowAndMessages
- [ ] Others
  - [ ] ColoredTabPages

* A Very basic window
** Plain =ns-window=
First, load =coca= package:

#+begin_src lisp
(ql:quickload :coca)
#+end_src

the following codes are assuming you're running codes
under =coca= package.

#+begin_src lisp
(in-package :coca)
#+end_src

#+begin_src lisp :noweb yes no-export
<<terminate-app-loop-when-close-window>>

(tmt:with-body-in-main-thread (:blocking t)
  (sb-int:set-floating-point-modes :traps nil)
  (let ((app (ns-app))
        (win (alloc-init 'ns-window
                         :frame   (make-ns-rect :x 100 :y 100
                                                :w 300 :h 300)
                         :title   "A Very basic window"
                         :visiblep t)))
    (run app)))
#+end_src

#+html: <details><summary>notes...</summary>
Here we use =terminate= to terminate =ns-app=,
which is the =NSApplication= of the application.

#+name: terminate-app-loop-when-close-window
#+begin_src lisp
(defmethod window-should-close ((self ns-window) sender)
  (terminate (ns-app) sender)
  t)
#+end_src

if you found your lisp also dies, it's normal.
#+html: </details>

*Reference*:
+ [[https://github.com/gammasoft71/Examples_Cocoa/blob/master/src/Applications/Application/Application.m][Application.m]] ([[https://github.com/gammasoft71/Examples_Cocoa/][Cocoa examples (github:gammasoft71/Examples_Cocoa)]])

*Explain*:
+ =ns-app= invokes =[NSApplication sharedApplication]= and return the =NSApp=,
  which handles the application event-loop of a Cocoa application (ref: [[https://developer.apple.com/documentation/appkit/nsapp?language=objc][NSApp]])
+ =alloc-init= is equal to calling =(init (alloc 'ns-window) ...)=,
  you could implement your own =init= (lisp generic function) to customize
  how to initialize the ObjC object.

  Note: =init= doesn't overwrites ObjC method =init=, so you can invoke
  ObjC =init= like =(invoke object "init")= within your lisp =init= [fn:lispworks-init].

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (find-method #'init () (list (find-class 'ns-window))) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Initializes the window with the specified values.
  Return the initialized `ns-window'.

  Parameters:
  + FRAME: `ns-rect'
    Origin and size of the window’s content area in screen
    coordinates. Note that the window server limits window position
    coordinates to ±16,000 and sizes to 10,000.
  + STYLE: see `ns-window-style-mask' (default `*ns-window-style*')
    The window’s style. It can be NSBorderlessWindowMask, or it can
    contain any of the options described in NSWindowStyleMask, combined
    using the C bitwise OR operator. Borderless windows display none of
    the usual peripheral elements and are generally useful only for
    display or caching purposes; you should normally not need to create
    them. Also, note that a window’s style mask should include
    NSTitledWindowMask if it includes any of the others.
  + BACKING: see `ns-backing-store-type' (default `*ns-backing-store*')
    Specifies how the drawing done in the window is buffered by the
    window device, and possible values are described in
    NSBackingStoreType.
  + DEFER:
    Specifies whether the window server creates a window device for the
    window immediately. When true, the window server defers creating the
    window device until the window is moved onscreen. All display
    messages sent to the window or its views are postponed until the
    window is created, just before it’s moved onscreen.
  + SCREEN: `ns-screen'
    Specifies the screen on which the window is positioned. The content
    rectangle is positioned relative to the bottom-left corner of
    screen. When nil, the content rectangle is positioned relative to
    (0, 0), which is the origin of the primary screen.

  Styls Modification:
  + VISIBLE:
    if window is visible on screen (default `t')
  + HAS-SHADOW:
    if window has shadow (default `t')
  + OPAQUE:
    if window is opaque (default `nil')
  + TITLE:
    the title of window (default not set)

  Dev Note:
  this invokes
  + initWithContentRect:styleMask:backing:defer:screen:
  + initWithContentRect:styleMask:backing:defer:

  see https://developer.apple.com/documentation/appkit/nswindow/init(contentrect:stylemask:backing:defer:)?language=objc
  see https://developer.apple.com/documentation/appkit/nswindow/init(contentrect:stylemask:backing:defer:screen:)?language=objc
  #+end_example
  #+html: </details>
+ =(sb-int:set-floating-point-modes :traps nil)= is needed on SBCL to avoid
  float traps stucking the main loop

** =ns-window= with =ns-text-field=
#+begin_src lisp :noweb yes no-export
<<terminate-app-loop-when-close-window>>

(tmt:with-body-in-main-thread ()
  (sb-int:set-floating-point-modes :traps nil)
  (let ((app   (ns-app))
        (win   (alloc-init 'ns-window
                           :frame   (make-ns-rect :x 100 :y 100
                                                  :w 300 :h 300)
                           :title   "A Very basic window"
                           :visiblep t))
        (label (alloc-init 'ns-text-field
                           :frame       (make-ns-rect :x 5 :y 100 :w 290 :h 100)
                           :font        (as-ns-font :label
                                                    :traits '(:italic :bold)
                                                    :size   45)
                           :text        "Hello World! "
                           :bezeledp    nil
                           :backgroundp nil
                           :editablep   nil
                           :selectablep nil
                           :text-color  #(0.0 0.5 0.0))))
    (add-subview win label)
    (run app)))
#+end_src

#+attr_html: :width 80%
#+attr_org: :width 300px
#+caption: Hello World (with label)
[[file:./hello-world.png]]

*Reference*:
+ [[https://github.com/gammasoft71/Examples_Cocoa/blob/master/src/HelloWorlds/HelloWorld/HelloWorld.m][HelloWorld.m]] ([[https://github.com/gammasoft71/Examples_Cocoa/][Cocoa examples (github:gammasoft71/Examples_Cocoa)]])

*Explain*:
+ =(alloc-init 'ns-text-field)=

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (find-method #'init () (list (find-class 'ns-text-field))) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Initialize NSTextField.

  Parameters:
  + FRAME: `ns-rect'
    The frame rectangle for the created view object.
    If setting, will use initWithFrame: method to initialize the
    `ns-text-field'.
  + TEXT:
    The string value of `ns-text-field' (see `string-value')

  Styles Parameters:
  + DRAWS-BACKGROUND-P:
    if or not draws background (see `draws-background-p')
  + BACKGROUND-COLOR:
    set the text field background color (see `background-color')
    if setting, will force DRAWS-BACKGROUND-P as `t'
  + TEXT-COLOR:  set the text color (see `text-color')
  + EDITABLEP:   set the text field is editable or not (see `editablep')
  + SELECTABLEP: set the text field is selectable or not (see `selectablep')
  + FONT:        set the text field (see `as-ns-font')
  + BEZELEDP:    set if draws bezeled background (boarder) (see `bezeledp')
  #+end_example
  #+html: </details>
+ =:label= font in Coca is wrapped by =as-ns-font= method

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (find-method #'as-ns-font () (list (c2mop:intern-eql-specializer :label))) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Returns the font used for standard interface labels in the
  specified size.

  This invokes ObjC method labelFontOfSize:

  The label font (Lucida Grande Regular 10 point) is used for the labels
  on toolbar buttons and to label tick marks on full-size sliders. See
  The macOS Environment in macOS Human Interface Guidelines for more
  information about system fonts.

  see https://developer.apple.com/documentation/appkit/nsfont/labelfont(ofsize:)?language=objc
  #+end_example

+ =:green= color in Coca is wrapped by =as-ns-color= method

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (find-method #'as-ns-color () (list (c2mop:intern-eql-specializer :green))) t)
  #+end_src

  #+RESULTS:
  : Returns a color object whose RGB value is 0.0, 1.0, 0.0 and whose
  : alpha value is 1.0.
+ =add-subview= add =label= to subview (like HTML children) of =win=

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (find-method #'add-subview () (list (find-class 'ns-window) (find-class 'ns-view))) t)
  #+end_src

  #+RESULTS:
  : This is equal to calling (add-subview (content-view WINDOW) SUBVIEW).

** Custom ObjC class and custom ObjC methods
If don't want =(ns-app)= being terminated for all the =ns-window=,
we could define a new ObjC class and use CLOS generic method to implement
different logic for the ObjC class.

#+begin_src lisp
(define-objc-class ("MyWindow" my-window) (ns-window)
  ((label :accessor my-label))
  (:documentation "The window will stop `ns-app' when closed. "))

(defmethod window-should-close ((self my-window) sender)
  (terminate (ns-app) sender)
  t)

(defmethod init ((self my-window)
                 &rest plist
                 &key
                   (label "Hello ObjC Class")
                   (title "Hello World"))
  (invoke-super (self plist)
    (:title title))
  (setf (my-label self)
        (alloc-init 'ns-text-field
                    :frame       (make-ns-rect :x 5 :y 100 :w 290 :h 100)
                    :font        (as-ns-font :label
                                             :traits '(:italic :bold)
                                             :size   45)
                    :text        label
                    :bezeledp    nil
                    :backgroundp nil
                    :editablep   nil
                    :selectablep nil
                    :text-color  #(0.0 0.5 0.0)))
  (add-subview self (my-label self)))

(tmt:with-body-in-main-thread (:blocking t)
  (sb-int:set-floating-point-modes :traps nil)
  (let ((app (ns-app)))
    (alloc-init 'my-window
                :frame   (make-ns-rect :x 100 :y 100
                                       :w 300 :h 300)
                :visiblep t)
    (run app)))
#+end_src

*Explain*
+ =define-objc-class=: this defines a new ObjC class =MyClass=
  and wrap as lisp class of name =my-window=.

  Note that although it's possible to define a ObjC Ivar using
  syntax like =("IvarName" :reader balabala)=. But it's not
  recommanded since this does not support dynamically redefine
  like CLOS =defclass=.

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (macro-function 'define-objc-class) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC Class of NAME.

  Example:

      ;; for existing ObjC class,
      ;; `define-objc-class' acts like declaration
      ;; it's direct super class could be ignored
      (define-objc-class \"NSWindow\" ()
        ((\"objcProperty\" :getter \"getObjCProperty\"
                           :setter \"setObjCProperty:\"
                           :before string-to-ns-string))
        (:documentation \"Foo... \"))

      ;; for non-existing ObjC class,
      ;; `define-objc-class' defines a new ObjC class
      (define-objc-class \"MyWindow\" (ns-window) ())

  Syntax:

      (define-objc-class
          { \"OBJC-NAME\" | (\"OBJC-NAME\" &optional LISP-NAME) }
          DIRECT-SUPERCLASS
          ({
               (OBJC-PROPERTY &key before after reader accessor documentation)
             | (LISP-SLOT &key LISP-SLOT-DEFINITIONS...)
           }*)
        CLASS-OPTIONS)

  + OBJC-NAME: string of ObjC class name
  + LISP-NAME: lisp name of ObjC class (optional)
  + DIRECT-SUPERCLASS:
    if not empty, will be used to declare new ObjC class
    if the ObjC class is not defined before;
    if empty, it's equal to modify the class infomations
  + CLASS-OPTIONS:
    + :documentation: set the documentation of the class
  #+end_example
  #+html: </details>
+ =call-next-method=: this works like =super= in ObjC, but you
  could make full use of ObjC method combination. ([[https://www.lispworks.com/documentation/HyperSpec/Body/f_call_n.htm][ref (CLHS)]])

  Note: if you want to wrap ObjC method as lisp generic methods,
  you could use =define-objc-method=. The =window-should-close=
  is defined like:

  #+begin_src lisp
  (define-objc-method ("NSWindow" "windowShouldClose:" window-should-close) :bool
    ((sender :object)))
  #+end_src

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (macro-function 'define-objc-method) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Define ObjC instance METHOD for CLASS.

  Syntax:

      (define-objc-method (CLASS METHOD &optional NAME) RET
          ( { (VAR OBJC-ENCODING) }* )
        (:documentation \"docstring\")
        (:method ((self class) (arg ...))
          body)
        (:wrapper wrapper-function)
        (:default default-return-value)
        (:redefine REDEFINE))

  + CLASS: symbol or string of ObjC class
    this should be the root of ObjC class where the lisp generic function
    would be used to replace / define ObjC method IMP as callback
  + METHOD: string of method SEL name
  + NAME: lisp generic method name
    if not given, would generated by METHOD (see `coca.objc::objc-intern')
  + RET: ObjC type encoding
    it is recommanded to use `objc-basic-encoding'
  + LAMBDA-LIST:
    VAR: symbol of argument
    OBJC-ENCODING: ObjC type encoding for argument
  + WRAPPER: wrapper function to ensure the ObjC method return value
    is currectly parsed as ObjC acceptable value
  + DEFAULT: by default, raise warning with no method message.
    Use DEFAULT will provide default return value of objc method.

    Note: within DEFAULT, the VAR and SELF can be referred.
  + REDEFINE: redefine the CFFI callback and the default method
    (by default is `nil')

  Example:

      (define-objc-method (ns-window \"foo\") :bool ()
        (:documentation \"...\")
        (:wrapper as-boolean)
        (:method ((self ns-window))
          (call-next-method) ;; like [super ...] in ObjC
          (foo self)))
  #+end_example
  #+html: </details>

* Dialog
** ColorDialog
#+begin_src lisp
(define-objc-class ("ColorWindow" color-window) (ns-window) ())

(define-objc-method ("ColorWindow" "onButtonClick:" on-button-click) :void
    ((sender :object))
  (:method ((self ns-window) (sender t))
    (let ((panel (ns-color-panel :target self
                                 :action #'change-color
                                 :color  (background-color self))))
      (setf (visiblep panel) t))))

(defmethod change-color ((self ns-window) (sender t))
  (setf (background-color self) (color sender)))

(defmethod init ((self color-window) &rest keys &key)
  (let ((button (alloc-init 'ns-button
                            :frame (make-ns-rect :x 10 :y 265 :w 100 :h 32)
                            :title "Color..."
                            :bezel-style :rounded
                            :target self
                            :action #'on-button-click
                            :autoresizing '(:max-x-margin :min-y-margin))))
    (invoke-super (self keys)
      (:frame (make-ns-rect :x 100 :y 100 :w 300 :h 300))
      (:title "ColorDialog example")
      (:visiblep t))
    (add-subview self button)
    self))

<<window-should-close>>

(tmt:with-body-in-main-thread ()
  (sb-int:set-floating-point-modes :traps ())
  (let ((app (ns-app)))
    (setf (activation-policy app) :regular)
    (make-main-window (autorelease (alloc-init 'color-window)))
    (run app)))
#+end_src

#+attr_html: :width 80%
#+attr_org: :width 300px
#+caption: ColorDialog example
[[file:./color-dialog.gif]]

#+html: <details><summary>window-should-close</summary>
#+begin_src lisp
(defmethod window-should-close :after (self sender)
  (when (endp (remove-if (lambda (w)
                           (or (typep w 'ns-panel)
                               (eq w self)))
                         (windows (ns-app))))
    (terminate (ns-app) sender)))
#+end_src

*Reference*:
+ [[https://github.com/gammasoft71/Examples_Cocoa/blob/master/src/Dialogs/ColorDialog/ColorDialog.m][ColorDialog.m]] ([[https://github.com/gammasoft71/Examples_Cocoa/][Cocoa examples (github:gammasoft71/Examples_Cocoa)]])

*Note*: this might be rewritten in the future for clean code.
#+html: </details>

*Explain*:
+ =ColorWindow=: we define a new =ns-window= class which:
  + Holds a button with title =Color...=
  + if button clicked, send =on-button-click= (ObjC method =onButtonClick:=)
    action to target aka =ColorWindow= itself

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation (find-method #'init () (list (find-class 'ns-button))) t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Creates a standard push button with the title you specify.

  Parameters:
  + TARGET: The target object that receives action messages from the control.
  + ACTION: The action the button sends to the target.
    see `coerce-to-selector'
  + TITLE:  The localized title string to display on the button.
  + IMAGE:  The image to display in the body of the button.
  + BORDEREDP: if BUTTON has border
    see `borderedp'
  + BEZEL-STYLE: appearance of button border (`ns-bezel-style')
    see `bezel-style'
  + BEZEL-COLOR: color of the button’s bezel (`as-ns-color')
    see `bezel-color'
  + BUTTON-TYPE: button type (`*ns-button-type*')
    see `ns-button-type'

  Dev Note:
  at least one of TITLE and IMAGE should be given.
  #+end_example

  #+html: </details>
+ =ns-color-panel=: when ObjC environment invokes =on-button-click=
  method, a [[https://developer.apple.com/documentation/appkit/nscolorpanel?language=objc][NSColorPanel]] ([[https://developer.apple.com/documentation/appkit/nscolorpanel/shared?language=objc][sharedColorPanel]]) panel window will:
  + popup =(setf (visiblep panel) t)=
  + start with initial color (background color of current window)
  + when changing the color of color panel,
    will send a =action= (ObjC SEL as message) to =target=
    (current window) with (the color panel) itself.

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'ns-color-panel t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Returns the shared NSColorPanel instance, creating it if necessary.

  Parameters:
  + TARGET: sets the target of the receiver
  + ACTION: sets the color panel's action message (default `change-color')
  + COLOR:  sets the color panel initial color
  + CONTINUOUSP: whether the receiver continuously sends
    the action message to the target
  + MODE: sets the mode of the receiver (`ns-color-panel-mode')

  see https://developer.apple.com/documentation/appkit/nscolorpanel/shared?language=objc
  #+end_example

  #+html: </details>

** FontDialog
#+begin_src lisp
(define-objc-class ("FontWindow" font-window) (ns-window)
  ((label :accessor my-label)))

(define-objc-method ("FontWindow" "onButtonClick:" on-button-click) :void
    ((sender :object))
  (:method ((self font-window) sender)
    (ns-font-panel :font   (font (my-label self))
                   :target self
                   :action #'change-font
                   :sender self)))

(defmethod change-font ((self font-window) sender)
  (setf (font (my-label self)) (selected-font (ns-font-manager))))

(defmethod init ((self font-window) &rest keys &key)
  (let ((button (alloc-init 'ns-button
                            :frame (make-ns-rect :x 10 :y 365 :w 100 :h 32)
                            :title "Font..."
                            :bezel-style :rounded
                            :target self
                            :action #'on-button-click
                            :autoresizing '(:max-x-margin :min-y-margin)))
        (label  (alloc-init 'coca:ns-text-field
                            :frame (make-ns-rect :x 10 :y 10 :w 380 :h 345)
                            :text  "Coca is Cocoa in Common Lisp.
ABCDEFGHIJKLMNOPQRSTUVWXYZ
abcdefghijklmnopqrstuvwxyz
1234567890!@#$%^&*()-+_=
滚滚长江东逝水
凉凉")))
    (invoke-super (self keys)
      (:frame   (make-ns-rect :x 100 :y 100 :w 400 :h 400))
      (:title   "FontDialog example")
      (:visiblep t))
    (add-subview self button)
    (add-subview self (setf (my-label self) label))
    self))

<<window-should-close>>

(tmt:with-body-in-main-thread ()
  (sb-int:set-floating-point-modes :traps ())
  (let ((app (ns-app)))
    (setf (activation-policy app) :regular)
    (make-main-window (autorelease (alloc-init 'font-window)))
    (run app)))
#+end_src

#+attr_html: :width 80%
#+attr_org: :width 300px
#+caption: FontDialog example
[[file:./font-dialog.gif]]

*Reference*:
+ [[https://github.com/gammasoft71/Examples_Cocoa/blob/master/src/Dialogs/FontDialog/FontDialog.m][FontDialog.m]] ([[https://github.com/gammasoft71/Examples_Cocoa/][Cocoa examples (github:gammasoft71/Examples_Cocoa)]])

*Explain*:
+ =ns-font-panel= creates a [[https://developer.apple.com/documentation/appkit/nsfontpanel?language=objc][NSFontPanel]] to select fonts

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'ns-font-panel t)
  #+end_src

  #+RESULTS:
  : Returns the single NSFontPanel instance for the application,
  : creating it if necessary.
  :
  : Parameters:
  : + FONT:     `ns-font' object to be show in font panel
  : + MULTIPLE: If true, the Font panel indicates that more than one font
  :   is contained in the selection; if false, it does not.
  : + TARGET:   target to send ACTION when changing font
  : + ACTION:   action to be sent (default `change-font')

  #+html: </details>
+ =change-font= is the default ObjC callback function
  responding to the =NSFontPanel= font changing events

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'change-font t)
  #+end_src

  #+RESULTS:
  : Called to respond to font changing events.
  :
  : Parameters:
  : + SELF:   responder to the message
  : + SENDER: the control that send the message

  #+html: </details>

** Open/SaveDialog
#+begin_src lisp
(define-objc-class ("OpenSaveWindow" open-save-window) (ns-window)
  ((actions :initform (make-hash-table :test 'eq))))

(defmethod window-will-close :after ((self open-save-window) sender)
  (terminate (ns-app) sender))

(define-objc-method ("NSObject" "onButtonClick:" on-button-click) :void
    ((sender :object))
  (:method ((self open-save-window) sender)
    (with-slots (actions) self
      (let ((action (gethash sender actions)))
        (when action (funcall action))))))

(defmethod init ((self open-save-window) &rest keys &key)
  (let ((open (alloc-init 'ns-button
                          :frame  (make-ns-rect :x 10 :y 310 :w 100 :h 30)
                          :title  "Open..."
                          :action #'on-button-click
                          :target self))
        (save (alloc-init 'ns-button
                          :frame  (make-ns-rect :x 120 :y 310 :w 100 :h 30)
                          :title  "Save"
                          :action #'on-button-click
                          :target self))
        (text (alloc-init 'ns-text-field
                          :frame      (make-ns-rect :x 10 :y 10 :w 380 :h 300)
                          :editablep   t
                          :selectablep t)))
    (invoke-super (self keys)
      (:frame (make-ns-rect :x 100 :y 100 :w 400 :h 350))
      (:title "Save/Open example"))
    (with-slots (actions) self
      (setf (gethash open actions)
            (lambda ()
              (let ((file (ns-open-panel
                           :title                      "Read File"
                           :allows-multiple-selection-p nil
                           :expanded-p                  nil)))
                (when file
                  (setf (string-value text)
                        (uiop:read-file-string (first file)))))))
      (setf (gethash save actions)
            (lambda ()
              (let ((file (ns-save-panel :title     "Save File"
                                         :expanded-p nil)))
                (when file
                  (with-open-file (stream file
                                          :direction :output
                                          :if-exists :supersede
                                          :if-does-not-exist :create)
                    (write-string (string-value text) stream)))))))
    (add-subview self open)
    (add-subview self save)
    (add-subview self text)))
#+end_src

#+caption: Save/Open example
[[file:./open-save-window.gif]]

*Reference*
+ [[https://github.com/gammasoft71/Examples_Cocoa/blob/master/src/Dialogs/SaveFileDialog/SaveFileDialog.m][SaveFileDialog.m]] ([[https://github.com/gammasoft71/Examples_Cocoa/][Cocoa examples (github:gammasoft71/Examples_Cocoa)]])
+ [[https://github.com/gammasoft71/Examples_Cocoa/blob/master/src/Dialogs/OpenFileDialog/OpenFileDialog.m][OpenFileDialog.m]] ([[https://github.com/gammasoft71/Examples_Cocoa/][Cocoa examples (github:gammasoft71/Examples_Cocoa)]])

*Explain*
+ =ns-open-panel= and =ns-save-panel= is for opening a window
  requesting for opening and saving file

  #+html: <details><summary>documentation</summary>
  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'ns-open-panel t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Creates a new Open panel and initializes it.
  Return a list of pathname for opened files.

  Parameters:
  + TITLE
    save/open panel window title
  + PROMPT
    text to display in the default button
  + MESSAGE
    message text displayed in the panel
  + NAME-FIELD-LABEL:
    label text displayed in front of the filename text field
  + NAME-FIELD:
    user-editable filename currently shown in the name field
  + DIRECTORY-URL:
    current directory shown in the panel
  + CAN-CREATE-DIRECTORIES-P
    whether the panel displays UI for creating directories
  + CAN-SELECT-HIDDEN-EXTENSION-P
    whether the panel displays UI for hiding or showing
    filename extensions
  + SHOWS-HIDDEN-FILES-P
    whether the panel displays files that are normally
    hidden from the user
  + EXTENSION-HIDDEN-P
    whether to display filename extensions
  + ALLOWED-CONTENT-TYPES (`as-ut-type')
    a list of `ut-types' like specification that specify the
    files types to which you can save
  + CAN-CHOOSE-FILES-P
    whether the user can choose files in the panel
  + CAN-CHOOSE-DIRECTORIES-P
    whether the user can choose directories in the panel
  + RESOLVES-ALIASES-P
    whether the panel resolves aliases
  + ALLOWS-MULTIPLE-SELECTION-P
    whether the user may select multiple files and directories
  + ACCESSORY-VIEW-DISCLOSED-P
    whether the panel’s accessory view is visible
  + CAN-DOWNLOAD-UBIQUITOUS-CONTENTS-P
    whether the panel responds to iCloud documents that aren’t
    fully downloaded locally.
  + CAN-RESOLVE-UBIQUITOUS-CONFLICTS-P
    whether the panel responds to iCloud documents that have
    conflicting versions
  #+end_example

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'ns-save-panel t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Creates a new Save panel and initializes it with default information.
  Return pathname of selected save file path or nil if cancelled.

  Parameters:
  + TITLE
    save/open panel window title
  + PROMPT
    text to display in the default button
  + MESSAGE
    message text displayed in the panel
  + NAME-FIELD-LABEL:
    label text displayed in front of the filename text field
  + NAME-FIELD:
    user-editable filename currently shown in the name field
  + DIRECTORY-URL:
    current directory shown in the panel
  + CAN-CREATE-DIRECTORIES-P
    whether the panel displays UI for creating directories
  + CAN-SELECT-HIDDEN-EXTENSION-P
    whether the panel displays UI for hiding or showing
    filename extensions
  + SHOWS-HIDDEN-FILES-P
    whether the panel displays files that are normally
    hidden from the user
  + EXTENSION-HIDDEN-P
    whether to display filename extensions
  + ALLOWED-CONTENT-TYPES (`as-ut-type')
    a list of `ut-types' like specification that specify the
    files types to which you can save
  #+end_example

  #+html: </details>

* Controls
** Button
#+begin_src lisp
(define-objc-class ("ButtonWindow" button-window) (ns-window)
  ((label1  :reader label1)
   (label2  :reader label2)
   (buttons :initform (make-hash-table :test #'eq) :reader buttons)))

(define-objc-method ("ButtonWindow" "onButtonClick:" on-button-click) :void
    ((sender :object))
  (:method ((window button-window) sender)
    (let ((action (gethash sender (buttons window))))
      (when action (funcall action)))))

(defmethod init ((self button-window) &rest keys &key)
  (let ((label1  (autorelease
                  (alloc-init 'ns-text-field
                              :frame    (make-ns-rect :x 50 :y 50 :w 200 :h 20)
                              :text     "Button1 clicked 0 times"
                              :bezeledp  nil
                              :editablep nil)))
        (label2  (autorelease
                  (alloc-init 'ns-text-field
                              :frame    (make-ns-rect :x 50 :y 80 :w 200 :h 20)
                              :text     "Button2 clicked 0 times"
                              :bezeledp  nil
                              :editablep nil)))
        (button1 (autorelease
                  (alloc-init 'ns-button
                              :frame    (make-ns-rect :x 50 :y 225 :w 200 :h 25)
                              :target   self
                              :action   #'on-button-click
                              :title    "Button1")))
        (button2 (autorelease
                  (alloc-init 'ns-button
                              :frame   (make-ns-rect :x 50 :y 125 :w 200 :h 75)
                              :target   self
                              :action #'on-button-click
                              :title   "Button2"))))
    (invoke-super (self keys)
      (:frame (make-ns-rect :x 100 :y 100 :w 300 :h 300))
      (:title "Button example"))
    (add-subview self label1)
    (add-subview self label2)
    (add-subview self button1)
    (add-subview self button2)
    (let ((clicked1 0)
          (clicked2 0))
      (setf (gethash button1 (buttons self))
            (lambda ()
              (setf (string-value label1)
                    (format nil "Button1 clicked ~D times" (incf clicked1)))))
      (setf (gethash button2 (buttons self))
            (lambda ()
              (setf (string-value label2)
                    (format nil "Button2 clicked ~D times" (incf clicked2))))))))

(tmt:with-body-in-main-thread ()
  (sb-int:set-floating-point-modes :traps ())
  (let ((app (ns-app)))
    (autorelease (alloc-init 'button-window))
    (setf (activation-policy app) :regular)
    (run app)))
#+end_src

#+attr_html: :width 80%
#+attr_org: :width 300px
#+caption: Button example
[[file:./button.gif]]

*Reference*
+ [[https://github.com/gammasoft71/Examples_Cocoa/blob/master/src/Controls/Button/Button.m][Button.m]] ([[https://github.com/gammasoft71/Examples_Cocoa/][Cocoa examples (github:gammasoft71/Examples_Cocoa)]])

*Explain*
+ we use =buttons= (a =hash-table=) to store the action of each button
  clicked on =button-window=

  Of course, you can write your own logic to implement the button
  actions. For example, you could use =define-objc-method= like:

  #+begin_src lisp
  (define-objc-method ("ButtonWindow" "onButton1Click:" on-button1-click) :void
      ((sender :object))
    (setf (string-value (label2 self))
          (format nil "Button2 clicked ~D times" (incf (button2-counter self)))))
  #+end_src

  But I think my way is more flexiable. Anyway, there's more than one way
  to make things done in Lisp World.

** CheckBox


* Events
Use =define-objc-method= to define event handler methods in lisp side.
For example, a =window-will-close:= method should be defined like below:

#+begin_src lisp
(define-objc-method ("NSObject" "windowWillClose:" window-will-close) :void
    ((notification :object)))
#+end_src

then user should only care about how to implement =window-will-close=
method in lisp using only =defmethod=.

Currently interned ObjC methods:

** [[https://developer.apple.com/documentation/appkit/nswindowdelegate?language=objc][NSWindowDelegate]]
+ =window-did-resize=

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'window-did-resize t)
  #+end_src

  #+RESULTS:
  : Tells the delegate that the window has been resized.
  : see https://developer.apple.com/documentation/appkit/nswindowdelegate/windowdidresize(_:)?language=objc
+ =window-did-miniaturize=

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'window-did-miniaturize t)
  #+end_src

  #+RESULTS:
  : Tells the delegate that the window has been minimized.
  : see https://developer.apple.com/documentation/appkit/nswindowdelegate/windowdidminiaturize(_:)?language=objc
+ =window-did-deminiaturize=

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'window-did-deminiaturize t)
  #+end_src

  #+RESULTS:
  : Tells the delegate that the window has been deminimized.
  : see https://developer.apple.com/documentation/appkit/nswindowdelegate/windowdiddeminiaturize(_:)?language=objc
+ =window-did-move=

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'window-did-move t)
  #+end_src

  #+RESULTS:
  : Tells the delegate that the window has moved.
  : see https://developer.apple.com/documentation/appkit/nswindowdelegate/windowdidmove(_:)?language=objc
+ =window-did-change-screen=

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'window-did-change-screen t)
  #+end_src

  #+RESULTS:
  : Tells the delegate that the window has changed screens.
  : see https://developer.apple.com/documentation/appkit/nswindowdelegate/windowdidchangescreen(_:)?language=objc
+ =window-should-close=

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'window-should-close t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Tells the delegate that the user has attempted to close a window or
  the window has received a performClose: message.

  Parameters:
  + WINDOW:
  + SENDER: the window being closed

  This method may not always be called during window closing.
  Specifically, this method is not called when a user quits an
  application.

  Dev Note:
  Return `t' to allow sender to be closed; otherwise `nil'.
  By default this function returns `t'.
  #+end_example
+ =window-will-close=

  #+begin_src lisp :exports results :results verbatim replace :eval yes
  (documentation #'window-will-close t)
  #+end_src

  #+RESULTS:
  #+begin_example
  Tells the delegate that the window is about to close.

  Parameters:
  + WINDOW: WINDOW to be closed
  + NOTIFICATION: A notification named NSWindowWillCloseNotification.

  You can retrieve the NSWindow object in question by sending object to
  notification.

  Dev Note:
  this is called when window will close, do nothing by default
  #+end_example

* Literal Programming                                              :noexport:
** GenDoc
*NOTE*: this is only needed if publishing =readme.org= for Github
org-mode rendering.

#+begin_src elisp :results silent
(save-excursion
  (beginning-of-buffer)
  (while (search-forward-regexp
          "^\s*#\\+begin_src lisp :exports results"
          nil t)
    (org-ctrl-c-ctrl-c)
    (next-line)))
#+end_src

Use =:exports results= for Github org-mode to recongize.
Evaluating this would update all the =:exports results= code block
within current file.

* Footnotes

[fn:lispworks-init] This may more likely to be LispWorks' =:init-function=
when defining a new ObjC class, which is called to initialize ObjC object
from the lisp side.
